#! /usr/bin/env python

#-----------------------------------------------------------------------------
# This script parses a very specific output file format from LASTZ. The command 
# for generating that file is the following:
# lastz input.fa[nameparse=darkspace] query.fa --coverage=90 \
# --format=general:score,name1,strand1,size1,start1,end1,name2,strand2,identity,length1,align1 > out.csv
#
# The -o option generates a cleaned-up version of the same csv file that is more amenable
# to analysis in R.
# The -s option generates a file where each line corresponds to target, query and the difference between
# the ending position of the previous hit on the target sequence and the starting position of current hit.
# In effect it is the spacing between the repeats.
# The -p option generates a file where each line corresponds to target, query and the gaps inserted by
# LASTZ into the target sequence to get an alignment to the query
# The -r option generates a fasta file of target sequences after applying the following filtering and processing steps:
# 1) Sequences that have gaps introduced by LASTZ greater than the threshold number are removed.
# 2) The sequnces are ungapped and only sequences that have a length 165-180 bp are kept.
# 3) If the target sequence matches the "-" strand of the query, the sequence is reverse complemented
# and this is reflected by a "_R_" prefix added to their IDs.
#-----------------------------------------------------------------------------

import sys, csv, argparse
from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Alphabet import generic_dna

def extract_fasta(records, gaps_upperlimit):
	records = filter(lambda x: x[11].count("-") < gaps_upperlimit, records)
	print >>sys.stderr, "Recovered %d records with less than %d gaps in target sequence" %(len(records),gaps_upperlimit)
	ff = []
	for record in records:
		repeat = Seq(record[11], generic_dna)
		if len(repeat.ungap("-")) not in range(165,181):
			pass
		elif record[7] is "-":
				repeat = repeat.reverse_complement()
				ID = "_R_"+str(record[1])+":"+str(record[4])+"-"+str(record[5])
				ff.append(SeqRecord(repeat.ungap("-"), id = ID, description = ""))
		else:
			ID = str(record[1])+":"+str(record[4])+"-"+str(record[5])
			ff.append(SeqRecord(repeat.ungap("-"), id = ID, description = ""))
	return ff

def repeat_gaps(records):
	prev_contig = 0
	prev_query = 0
	gaps = []
	for record in records[1:]:
		this_contig = record[1] # establish which contig we are in
		this_query = record[6] # establish which contig we are in 

		if (prev_contig != this_contig) or (prev_query != this_query): # if this is the start of a new contig or query then resetstop
			prev_contig = this_contig
			prev_query = this_query
			repeat = Seq(record[11], generic_dna)
			g = repeat.count('-')
			gaps.append([this_contig, this_query, g])
		else:
			repeat = Seq(record[11], generic_dna)
			g = repeat.count('-')
			gaps.append([this_contig, this_query, g])
	return gaps

def repeat_spacing(records):
	prev_contig = 0
	prev_query = 0
	spacing = []
	for record in records[1:]:
		this_contig = record[1] # establish which contig we are in
		this_query = record[6] # establish which contig we are in 

		if (prev_contig != this_contig) or (prev_query != this_query): # if this is the start of a new contig or query then resetstop
			prev_contig = this_contig
			prev_query = this_query
			prev_stop = int(record[5]) + 1
		else:
			this_start = int(record[4])
			spacing.append([this_contig, this_query, this_start - prev_stop])
			prev_stop = int(record[5]) + 1 # reset the prev_stop to reflect the end of current repeat
	return spacing

def collect_records(fp):
	records = []

	for line in fp:
		if line[0] == '#':
			header = [line[1:].strip().split('\t')][0]
			records.append(header)
		else:
			record = [line.strip().split('\t')]
			record = record[0] # Going form 'list of a list' to just a list

			if '|' in record[1]:
				record[1] = record[1].split('|')[3] #shortening the PacBio contig name

			record[9] = record[9].split('%')[0] #removing % sign from pctIdentity column
			records.append(record)
	return records

def main():
	parser = argparse.ArgumentParser(description='This script parses a specific "csv" output generated by LASTZ')
	parser.add_argument('input', action="store", type=str, help="Filename of .csv file in current folder")
	parser.add_argument('-o', '--output', action="store_true", help="Generates a cleaned up version of the input csv file")
	parser.add_argument('-s', '--spacing', action="store_true", help="Calculates spacing between repeats")
	parser.add_argument('-p','--gaps', action="store_true", help="Generates a file with distribution of gaps inserted to get an alignment")
	parser.add_argument('-r','--repeats', action="store_true", help="Generates fasta file with sequences identified in target(s)")
	parser.add_argument('-g','--gaps_upperlimit', action="store", default=20, type=int,help="The outer limit of the number of gaps in target sequence")
	args = parser.parse_args()

	lastz_input = args.input
	fp = open(lastz_input)
	records = collect_records(fp)
	print >>sys.stderr, "Recovered %d records" %(len(records) -1)
	
	filename = lastz_input.split(".")[0]

	if args.output:
		out_file = open(filename+".forR.csv", "wb")
		writer = csv.writer(out_file, delimiter="\t", quoting = csv.QUOTE_MINIMAL)
		for record in records:
			writer.writerow(record)
		out_file.close()

	if args.spacing:
		spacing = repeat_spacing(records)
		out_file = open(filename+".spacing.csv","wb")
		writer = csv.writer(out_file, delimiter="\t", quoting = csv.QUOTE_MINIMAL)
		for line in spacing:
			writer.writerow(line)
		out_file.close()

	if args.gaps:
		gaps = repeat_gaps(records)
		out_file = open(filename+".gaps.csv","wb")
		writer = csv.writer(out_file, delimiter="\t", quoting = csv.QUOTE_MINIMAL)
		for line in gaps:
			writer.writerow(line)
		out_file.close()

	gaps_upperlimit = args.gaps_upperlimit

	if args.repeats:
		repeats = extract_fasta(records,gaps_upperlimit)
		print >>sys.stderr, "Recovered %d records of lengths 165-180 bp" %len(repeats)
		out_handle = open(filename+".fa","w")
		SeqIO.write(repeats, out_handle, "fasta")

if __name__ == '__main__':
	main()
